# 🔍 Binary Size Investigation & Optimization

**Date:** October 19, 2025  
**Platform:** macOS (darwin 24.6.0)  
**Optimization:** MinSizeRel + Strip

---

## 🎯 Problem

Initial Release build Binary-Größen waren unerwartet groß:
- tiny-clj-repl: 303KB
- tiny-clj-stm32: 239KB
- Ziel: <100KB (historisch erreicht)

## 🔍 Ursachenanalyse

### 1. Build-Konfiguration
**Problem:** CMake verwendete `-O3` (Geschwindigkeit) statt `-Os` (Größe) für macOS

**Lösung:** Umstellung auf `MinSizeRel` Build-Typ mit `-Os`

### 2. __PAGEZERO Sektion
**Beobachtung:** `__PAGEZERO` Sektion zeigte 4GB (0x100000000)

**Erklärung:** Dies ist **normale** Verhalten auf macOS ARM64 für Speicherschutz (virtuelle Adresse, nicht Dateigröße)

**Versuchte Lösung:** `-Wl,-no_pie` wurde ignoriert (arm64 erfordert PIE)

**Ergebnis:** Kein Problem - dies beeinflusst nicht die tatsächliche Binary-Größe

### 3. Debug-Symbole
**Problem:** Binaries enthielten Debug-Symbole trotz Release-Build

**Lösung:** `strip` Kommando zum Entfernen der Debug-Symbole

---

## 📊 Optimierungsergebnisse

### Schritt-für-Schritt Verbesserung

| Build-Typ | Flags | tiny-clj-repl | tiny-clj-stm32 | unity-tests |
|-----------|-------|---------------|----------------|-------------|
| **Initial (Release)** | `-O3` | 303KB | 239KB | 424KB |
| **Release + Dead Strip** | `-O3 -Wl,-dead_strip` | 140KB | 107KB | 162KB |
| **MinSizeRel** | `-Os -Wl,-dead_strip` | 112KB | 110KB | 150KB |
| **MinSizeRel + no_pie** | `-Os -Wl,-dead_strip -Wl,-no_pie` | 96KB | 93KB | 134KB |
| **+ strip** | (nach strip) | **86KB** | **86KB** | **120KB** |

### Finale Ergebnisse

**Nach Optimierung:**
- **tiny-clj-repl:** 86KB (**-72% von 303KB**)
- **tiny-clj-stm32:** 86KB (**-64% von 239KB**) ✅ **<100KB Ziel erreicht!**
- **unity-tests:** 120KB (**-72% von 424KB**)

---

## 🚀 Angewandte Optimierungen

### 1. Compiler-Flags
```cmake
-Os                      # Optimize for size (not speed)
-DNDEBUG                # Disable assertions
-ffunction-sections     # Each function in separate section
-fdata-sections         # Each data in separate section
```

### 2. Linker-Flags
```cmake
-Wl,-dead_strip         # Remove unused code/data (macOS)
-Wl,-no_pie             # Disable PIE (ignored on arm64)
```

### 3. Post-Build
```bash
strip <binary>          # Remove debug symbols
```

---

## 📈 Text/Data/BSS Breakdown

**Final Build (stripped):**
```
__TEXT:  65KB  (executable code)
__DATA:  16KB  (initialized data)
```

**Savings from Tagged Pointer System:**
- 50% smaller CljObject headers (8→4 bytes)
- Zero allocation for immediate values
- Better code density

---

## 🎯 Vergleich mit Baseline

**Baseline (Oktober 18, 2025):**
- tiny-clj-repl: 508KB
- tiny-clj-stm32: 258KB

**Current (Oktober 19, 2025 - Optimized + Tagged Pointers):**
- tiny-clj-repl: 86KB (**-83% / 422KB Einsparung**)
- tiny-clj-stm32: 86KB (**-67% / 172KB Einsparung**)

---

## 🔮 Weitere Optimierungsmöglichkeiten

### 1. Link-Time Optimization (LTO)
```cmake
set(CMAKE_INTERPROCEDURAL_OPTIMIZATION ON)
```
**Erwartete Einsparung:** 5-10%

### 2. Aggressive Dead Code Elimination
```cmake
-fvisibility=hidden
-flto
```
**Erwartete Einsparung:** 10-15%

### 3. Custom Linker Script
- Merge sections
- Remove unused sections
- Optimize alignment

**Erwartete Einsparung:** 5-10%

### 4. Feature-Stripping für Embedded
- Remove REPL features
- Remove debug output
- Minimal clojure.core

**Erwartete Einsparung:** 20-30%

---

## 🎯 Conclusions

✅ **Ziel erreicht:** tiny-clj-stm32 ist jetzt **86KB** (<100KB)

✅ **Massive Verbesserung:** 83% Reduktion von 508KB → 86KB (REPL)

✅ **Tagged Pointers helfen:** Kleinere Objekte = bessere Code-Dichte

### Empfehlungen

1. **Für Produktion:** Immer `MinSizeRel` + `strip` verwenden
2. **Für Embedded:** Weitere Feature-Stripping möglich
3. **Für Performance:** `-O3` nur wenn Geschwindigkeit kritisch

---

*Generated by: Tiny-CLJ Development Team*  
*Report Date: 2025-10-19*  
*Status: ✅ <100KB Ziel erreicht!*

