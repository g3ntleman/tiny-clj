
R"CLOJURE(
; ============================================================================
; Arithmetic Functions
; ============================================================================
(def add (fn [a b] (+ a b)))
(def sub (fn [a b] (- a b)))
(def mul (fn [a b] (* a b)))
(def div (fn [a b] (/ a b)))
(def mod (fn [a b] (- a (* b (/ a b)))))
(def inc (fn [x] (+ x 1)))
(def dec (fn [x] (- x 1)))
(def square (fn [x] (* x x)))

; ============================================================================
; Numeric Predicates
; ============================================================================
(def zero? (fn [x] (= x 0)))
(def pos? (fn [x] (> x 0)))
(def neg? (fn [x] (< x 0)))
(def even? (fn [x] (= (mod x 2) 0)))
(def odd? (fn [x] (not (even? x))))

; ============================================================================
; Comparison & Logic
; ============================================================================
(def not (fn [x] (if x false true)))
(def max (fn [a b] (if (> a b) a b)))
(def min (fn [a b] (if (< a b) a b)))

; ============================================================================
; Collection Functions
; ============================================================================
(def second (fn [coll] (first (rest coll))))
(def empty? (fn [coll] (= (count coll) 0)))

; ============================================================================
; Functional Programming Core
; ============================================================================
(def map (fn [f coll]
  (if (empty? coll)
    '()
    (cons (f (first coll)) (map f (rest coll))))))

; ============================================================================
; Utility Functions
; ============================================================================
(def identity (fn [x] x))
(def constantly (fn [x] (fn [y] x)))
)CLOJURE"
